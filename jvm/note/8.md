# 垃圾回收 (gc)

## 垃圾判断算法
- 引用计数算法 (Reference Counting)
给对象添加一个引用计数器，当有一个引用指向它，计数器加1；当引用失效，计数器减1，任何时刻计数器为0的对象就是不可能再被使用的。
引用计数算法无法解决对象循环引用的问题。

- 根搜索算法 (Root Tracing)
通过一系列 "GC Roots" 的点作为起始进行搜索，当一个对象到 GC Roots 没有任何引用链(Reference Chain)相连，则证明此对象是不可用的。

在 Java 语言中，GC Roots 包括：
  在虚拟机栈中(本地变量)的的引用
  方法区中的静态引用 （那方法区中的GC怎么办？）
  JNI(Native方法)中的引用

方法区
  - JVM规范表示可以不要求虚拟机在这个区域实现GC，因为性价比一般比较低
  - 常规应用在 新生代 的一次 GC 一般可以回收 70% ~ 95% 的空间
  - 当前的商业 JVM 都有实现方法区的GC，主要回收两部分内容：废弃常量与无用类

  
## 垃圾回收算法

- 标记-清除算法(Mark-Sweep)
  算法分为"标记"和"清除"两个阶段，首先标记出所有需要回收的对象，然后回收所有需要回收的对象。
  缺点
    效率问题：标记和清除两个过程效率都不高，堆越大，GC越慢
    空间问题：标记清除之后，会产生内存碎片

- 标记-整理算法(Mark-Compact)
  标记过程是一样的，但后续不是直接清除，而是往一端移动，然后直接清除掉另外一端的内存。
  没有内存碎片。
  耗费时间整理(压缩)

— 复制算法(Copying)
  将内存划分为两块，每次只使用其中一块，当其中一个区内存使用完了，将还存活的对象复制到另外一个区。
  不会有内存碎片问题。
  缺点：浪费一半内存

  Oracle HotSpot 中，新生代使用了这种算法。默认情况下，Eden 和 survivor 的比例是 8:1:1，只有10%的内存`浪费`。
  缺点：对象存活率较高时，回收效率有所下降

- 分代回收算法(Generation)
  分为新生代和老年代
  新生代每次GC都有大批对象死去，使用「复制算法」
  对象在eden区出生，当eden满的时候，存活的对象复制到一个Survivor区。当一个Survivor区满时，此区存活的对象和eden区存活的对象复制到另外一个survivor区。
  老年代一般采用"标记-清除"或"标记-整理"算法
  可以根据具体应用需求选择合适的垃圾回收器，吞吐量？响应时间？

内存分配
  - 堆上分配，大多数对象在eden区分配，偶尔会直接在老年区分配
  - 栈上分配，局部变量

引用类型：
- Strong 
- Soft:内存不够时一定会被GC，长期不用也会被GC
- Weak:一定会被GC，会在Reference Queue中通知
- Phantom:本来就没引用，当从jvm heap 中回收时会通知

## 垃圾回收器的实现和选择

![垃圾回收算法](../img/垃圾回收算法.png)

- ScaVenge GC(Minor GC)
  触发时机：Eden空间满了
  理论上Eden区大多数对象都会在ScaVenge GC回收，复制算法的效率很高。
- Full GC
  对整个JVM堆回收
  主要触发时机：Old满了；Perm满了；System.gc()
  效率很低，尽量减少Full GC
  Stop The World (STW)

垃圾收集器的 并行 和 并发
- 并行(Parallel): 指多个收集器的线程同时工作，但用户线程处于等待状态
- 并发(Concurrent): 指收集器在工作的同时，可以允许用户线程工作。并发不代表解决了GC停顿问题，在关键的步骤还是要停顿，如标记垃圾的时候。
                    但在清除垃圾的时候，用户线程可以和GC线程并发执行。


## 垃圾收集器
- Serial收集器 
  最早的收集器
  单线程收集器，收集时会暂停所有用户线程。虚拟机在Client模式下，默认使用此收集器。                    
  在新生代，使用复制算法；在老年代，使用复制-整理算法
  优点：单线程，没有多线程切换开销，简单实用
  
![Serial收集器](../img/Seria收集器.png)

- ParNew收集器
  是Serial收集器的多线程版本，除了在垃圾收集时使用多个收集线程外，其余行为包括算法、STW、对象分配规则、回收策略都与Serial收集器一样。
  Server模式下的默认新生代收集器
  可以通过 -XX:ParallelGCThreads 来控制GC线程数
  缺点：在单CPU内核的情况下，并不会比Serial收集器有很好的效果